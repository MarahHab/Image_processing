# -*- coding: utf-8 -*-
"""Copy of ImageProcessingEx_05_FFT.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1noHMQzHT0X-E8CXapTmtld7gN9766fEV

# Image Processing Assignment 5: Fast Fourier Transform

Before we start, please put your names and IDs in following format

: Firstname LASTNAME, #00000000   //   (e.g.) Dana LEVI, #12345678

**Your Answer:**   
Marah Habashi, #211668751

Celine Karam, #314658428

In this exercise, you will implement the **fft_clean**  algorithm.

Method: as explained in class.

Notes:
*   Write your code in the dedicated areas (TODO blocks). You can add helper functions.
*   Submission email should include a link to the Colab submission notebook located on your Google Drive with Commenter access right to nev1958a@gmail.com
*   The solution notebook should be able to be run (‘Run all’) with no errors.
In case of errors, the submission will be disqualified.
*   The grade will depend on correct performance on several grayscale images and on clean programming and documentation.
*   Do not forget to add the Names and Student I.D. at the top of the notebook.
*   All images are given as 2-dimensional matrices of type `float`, with values in the range [0..1].
*   Pay Attention! In the following function, the returned images must be the same size as the original Images!

Please implement the following function:
1. Write the `fft_clean` function which receive 4 images (fft1-4), cleans them and returns the 4 clean images using fft.

## Setup Code
Before getting started, we need to run some boilerplate code to set up our environment. You will need to rerun this setup code each time you start the notebook.
"""

import os
import requests
from io import BytesIO
import numpy as np
import matplotlib.pyplot as plt
import plotly.express as px
import PIL
from scipy.signal import convolve

GITHUB_PATH = 'https://raw.githubusercontent.com/dnevo/ImageProcessing/main/images/'

def read_file(file_name:str, file_path:str=GITHUB_PATH) -> np.ndarray:
    '''
    Accept an image file name (defaulty located in GitHub) and return the image 
    in a numpy array.

    Args:
        file_name: the file name
        file_path: the file path.. Default value is Doron's Github repo.

    Returns:
        the image converted into a Numpy array.
    '''
    file_path = os.path.join(file_path, file_name)
    response = requests.get(file_path)
    fp = BytesIO(response.content)

    img_pil = PIL.Image.open(fp)
    return np.array(img_pil, dtype='int16')

def plot_images(img1:np.array, img2:np.array):
    fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(14, 6))
    axes[0].imshow(img1, cmap='gray')
    axes[1].imshow(img2, cmap='gray')

"""## `fft_clean`"""

def fft_clean(img1: np.array, img2: np.array, img3: np.array, img4: np.array) \
    -> (np.array, np.array, np.array, np.array):
    '''
    This function receives 4 grayscale images and clean them using FFT algorithm.

    Args:
        img1:   image array in float format (range: 0..1) - the source grayscale 
                image.
        img2:   image array in float format (range: 0..1) - the source grayscale 
                image.
        img3:   image array in float format (range: 0..1) - the source grayscale 
                image.
        img4:   image array in float format (range: 0..1) - the source grayscale 
                image.

    Returns:
        img_c1:    array in int format (values: 0, 1) - the cleaned image.
        img_c2:    array in int format (values: 0, 1) - the cleaned image.
        img_c3:    array in int format (values: 0, 1) - the cleaned image.
        img_c4:    array in int format (values: 0, 1) - the cleaned image.
    '''
    ######################################################################
    # TODO: Implement The fft algorithm.
    ######################################################################
    fft1 = np.fft.fft2(img1)
    fft2 = np.fft.fft2(img2)
    fft3 = np.fft.fft2(img3)
    fft4 = np.fft.fft2(img4)
    

    f1 = np.fft.fftshift(fft1)
    f2 = np.fft.fftshift(fft2)
    f3 = np.fft.fftshift(fft3)
    f4 = np.fft.fftshift(fft4)


    f1[256,220] = 0
    f1[276,220] = 0

    img_c1 = np.fft.ifftshift(f1)
    img_c1 = np.fft.ifft2(img_c1)

    f2[225,157] = 0
    f2[255,173] = 0

    img_c2 = np.fft.ifftshift(f2)
    img_c2 = np.fft.ifft2(img_c2)

    f3[177,117] = 0
    f3[177,124] = 0
    f3[177,131] = 0
    f3[189,117] = 0
    f3[189,131] = 0
    f3[201,117] = 0
    f3[201,124] = 0
    f3[201,131] = 0
    
    img_c3 = np.fft.ifftshift(f3)
    img_c3 = np.fft.ifft2(img_c3)

    f4[286,251] = 0
    f4[299,240] = 0
    f4[299,262] = 0
    f4[312,251] = 0

    img_c4 = np.fft.ifftshift(f4)
    img_c4 = np.fft.ifft2(img_c4)

    ######################################################################
    #                            END OF YOUR CODE                        #
    ######################################################################
    return img_c1.real, img_c2.real, img_c3.real, img_c4.real

img1 = read_file(file_name='fft1.tiff') / 255
img2 = read_file(file_name='fft2.tiff') / 255
img3 = read_file(file_name='fft3.tiff') / 255
img4 = read_file(file_name='fft4.tiff') / 255

f1 = fft2(img2)
fig = px.imshow(np.log(np.abs(fftshift(f1))**2), color_continuous_scale='gray')
fig.update_layout(coloraxis_showscale=False)

img_c1, img_c2, img_c3, img_c4 = fft_clean(img1, img2, img3, img4)

plot_images(img1, img_c1)

plot_images(img2, img_c2)

plot_images(img3, img_c3)

plot_images(img4, img_c4)